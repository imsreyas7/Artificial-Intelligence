# -*- coding: utf-8 -*-
"""162_decant.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nl-LPe28jyMP6aO9qsSGzYWu6bu_Dq7D
"""

import numpy as np
from scipy.sparse.csgraph import shortest_path

def next_state(l,s):
    x=[]
    for i in l:
        if(i[0]==s[0] or i[1]==s[1] or i[2]==s[2] ): 
           
            if((s[0]!=8 and i[0]==8)or (s[1]!=5 and i[1]==5) or (s[2]!=3 and i[2]==3)): #one jug is completely filled 
                x.append(i)
            elif((s[0]!=0 and i[0]==0)or (s[1]!=0 and i[1]==0) or (s[2]!=0 and i[2]==0)): #one jug is comletely emptied
                x.append(i)
    return x            
    

l=[]
Q =[[a, b, c] for a in range (0, 9) for b in range (0, 6) for c in range (0, 4) if a + b + c == 8 and ((a == 8 or a == 0) or (b == 5 or b == 0) or (c == 3 or c == 0))]
G=[]
n=len(Q)

#creating adjacency matrix        
for i in range(0,n):
    x=[]
    a=next_state(Q,Q[i])
    
    for j in Q:
        if j in a:
            x.append(1)
        else:
            x.append(0)
    l.append(x)

    

#the possible final states
for i in Q:
    if 4 in i:
        G.append(i)

print(G)

'''
OUTPUT
[[1, 4, 3], [4, 1, 3], [4, 4, 0]]
'''



# 3 water jugs capacity -> (x,y,z) where x>y>z
# initial state (8,0,0)
# final state (4,4,0)
A = np.zeros((len(Q), len(Q)))

for i,node_1 in enumerate(Q):
    for j,node_2 in enumerate(Q):
        total_change = [node_1[0] - node_2[0], node_1[1] - node_2[1], node_1[2] - node_2[2]]
                 # Check 1: one of the jugs is not affected
        check_1 = (total_change[0]*total_change[1]*total_change[2]==0) 
                 # Check 2: one of the jugs gets full
        check_2 = (node_2[0]==8 and total_change[0]!=0) or (node_2[1]==5 and total_change[1]!=0) or (node_2[2]==3 and total_change[2]!=0)
                 # Check 3: one of the jugs gets empty
        check_3 = (node_2[0]==0 and total_change[0]!=0) or (node_2[1]==0 and total_change[1]!=0) or (node_2[2]==0 and total_change[2]!=0)
        adjacent = check_1 and (check_2 or check_3)
        if adjacent:
                A[i,j]=1

dist_mat, pred = shortest_path(A, return_predecessors=True, directed=True, unweighted=True)

index = 8
path = [8]
while index != 15:
    index = pred[15, index]
    path.append(index)

#path with (8,0,0) as starting node and (4,4,0) as end node
#print(dist_mat)   
list(reversed([Q[index] for index in path]))
#print(path)

'''
OUTPUT

[[8, 0, 0],
 [3, 5, 0],
 [3, 2, 3],
 [6, 2, 0],
 [6, 0, 2],
 [1, 5, 2],
 [1, 4, 3],
 [4, 4, 0]]

 '''